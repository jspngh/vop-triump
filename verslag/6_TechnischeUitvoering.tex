
\chapter{Technische uitvoering}

%Een beschrijving van de technische uitvoering van het project met de
%nodige figuren en een verantwoording van de ontwerpskeuzes.

% Structuur:
% Waarom
% Voornadelen / nadelen
% Werking
Triump bestaat uit twee grote delen. Enerzijds is er de frontend, dit is het gedeelte van Triump waarmee de gebruikers rechtstreeks intrageren. De frontend bestaat op zijn beurt uit twee delen, nl. een Android applicatie en een webinterface. Het tweede deel van de Triump infrastructuur is backend. Hiermee komen de gebruikers nooit rechtstreeks in contact. In onderstaande paragrafen wordt er dieper ingegaan op deze onderdelen. Figuur \ref{fig:algemene structuur backend} geeft een abstract overzicht van de infrastructuur.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{backend_algemene_structuur}
	\caption{Structuur backend}
	\label{fig:algemene structuur backend}

\end{figure}

\section{Backend}

\subsection{Google Cloud Endpoints}
\label{sec: GCE}
% restricities op aantal request
Google Cloud Endpoints (GCE) is een uitbreiding van Google App Engine (GAE). GAE is een bekend "Platform as a Service" gemaakt om applicaties uit te voeren op de infrastructuur van Google. GCE biedt naast de functionaliteiten beschikbaar in GAE een extra infrastructuur om op een relatief eenvoudige manier een backend API te generen. 
De extra infrastructuur aangeboden door GCE bestaat uit de endpoints. Deze endpoints verzorgen ondermeer de communicatie en authenticatie tussen mobiele gebruikers en de backendserver.
Aangezien de backend API nog steeds gehost wordt door Googles App Engine blijven alle functionaliteiten zoals "Datastore", "Google Cloud Messaging" en "Cron jobs" beschikbaar. Figuur \ref{fig:Architectuur Google Cloud Endpoints} geeft de architectuur van de Enpoint weer~\cite{Google_endpoints}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.3]{GCE}
	\caption{Architectuur Google Cloud Endpoints}
	\label{fig:Architectuur Google Cloud Endpoints}
\end{figure}

Het voornaamste voordeel van het werken met GAE is dat er tijdens ontwikkelfase geen rekening hoeft gehouden te worden met het  beheer en de administratie van de backend infrastructuur. Problemen zoals schaalbaarheid worden via dynamische rekenkracht allocatie opgelost. Daarnaast verzekert de App Engine een permanente beschikbaarheid van de servers worden doorgeschoven.

Desalniettemin brengt het gebruik van GAE meerdere nadelen met zich mee. De voornaamste zijn de restrictie op het aantal lees- en schrijfoperaties per dag, de sterk variërende duratie van lees- en schrijfoperaties en de afhankelijkheid van een externe organistatie. Aangezien elke nieuwe ontwikkelaar \$ 300 cadeau krijgt kon het eerste nadeel opgelost worden door het aantal operaties per dag van 50.000 naar 1.000.000 te verhogen. De reden waarom 1.000.000 operaties per dag noodzakelijk is om Triump draaiende te houden is dat elke entiteit binnen een query als één leesoperatie wordt beschouwd. Hierdoor neemt het aantal leesoperaties bij het uitvoeren van enkele geneste queries zeer snel toe.

\subsubsection{Datastore}

Triump maakt gebruik van App Engine Datastore als backend databank.

GAE Datastore verschillend van traditionele relationele databases door zijn specifieke architectuur. De database is namelijk zo ontworpen dat het automatisch meeschaalt met de toenmende hoeveelheid opgeslagen data. Een tweede verschil met relationele databanken is dat GAE Datastore schemaloos is. Hiermee wordt bedoeld dat objecten van een eenzelfde type verschillende eigenschappen kunnen hebben en dat eenzelfde eigenschap verschillende types kan hebben. 

Objecten in de database worden entiteiten genoemd. Een entiteit heeft meerdere eigenschappen, elk van deze eigenschappen kan één of meerdere waarden hebben. 

Aangezien de database schemaloos is en bijgevolg bijvoorbeeld geen types zal controleren of niet zal aangeven indien een vreemde sleutel niet bestaat ligt de verantwoordelijkheid van de in integriteit van de database volledig bij de ontwikkelaar. Tijdens de ontwikkeling werd dit gezien als het grootste nadeel van de GAE Datastore.

\subsubsection{Google Cloud Messaging}
% Notificaties
%https://developer.android.com/index.html
Google Cloud Messaging (GCM) voor Android is een dienst die het mogelijk maakt data (tot 4kB) te versturen van backend servers naar Android smartphones. De GCM servers staat in voor de connectie naar het mobiele toestel en een correcte aflevering van de berichten.

GCM wordt in Triump gebruikt als basis van het notificatie systeem. In de huidige implementatie ontvangt een gebruiker een notificatie indien hij of zij een promotie of event heeft gewonnen en bijgevolg een prijs heeft verdiend. Principieel werkt het systeem als volgt:
\begin{enumerate}
  \item Een gebruiker heeft een prijs gewonnen.
  \item De backend construeert een korte boodschap. De boodschap en gebruiker die de boodschap dient te ontvangen wordt doorgegeven aan de GCM dienst. 
  \item GCM dienst verstuurd de booschap naar het mobiele Android toestel.
  \item Op het toestel draait een permanente service die luistert naar binnenkomende boodschappen. De ontvangen boodschappen worden omgevormd tot een notificatie.
  \item De notificaties worden weergegeven op het toestel.
\end{enumerate}
Pijl (2) van figuur \ref{fig:algemene structuur backend} geeft aan dat er via GCM, vanop de backend servers, berichten worden gepusht naar de gebruikers.
\subsubsection{Cron jobs}

Een van de functionaliteiten die Google App Engine aanbiedt is de App Engine Cron Service. Deze service laat gebruikers toe bepaalde taken (cron jobs/chronical jobs) op regelmatige tijdstippen uit te laten voeren op de backend. In het geval van de backend van Triump is het noodzakelijk om beloningen (rewards) na het aflopen van evenementen voor gebruikers te laten generen. Hiervoor wordt gebruik gemaakt van een cron job, die geconfigureerd wordt in een java servlet.


%-----------------------------------------------

In de voorgaande paragrafen werden de gehanteerde technologieën kort toegelicht. In wat volgt komt uitleg bij het ontwerp en implementatie van de backend database en backend API gebruikmakend van deze technologieën. In de laatste paragrafen van deze sectie wordt het tweede deel van de backend besproken, nl. de Foursquare API.
  
\subsection{Ontwerp backend}


\subsubsection{Database}

Figuur \ref{fig:Backend ER} toont een ER diagram van de kern van de backend database. De belangrijkste tabellen van de database zijn User, Event, Venue, Group en Checkin. 

Een user entiteit wordt aangemaakt wanneer een gebruiker zicht voor het eerst authenticeert bij de backend. Het ID van een gebruiker binnen de Triump database is indentiek aan het ID van een gebruiker binnen de Foursquare database. Informatie zoals voornaam, achternaam en e-mailadres van een gebruiker wordt bekomen via een request naar de Foursquare API. In sectie \ref{Foursquare API} komt de werking van de Foursquare API aan bod. Pijl (4) van figuur \ref{fig:algemene structuur backend} geeft de afhankelijkheid tussen Triumps database en de Foursquare database weer.

Venue entiteiten worden aangemaakt wanneer een gebruiker voor het eerst incheckt op een nieuwe locatie. Opnieuw is de ID van een venue entiteit indentiek aan het ID van de entiteit binnen Foursquare. Een datum en tijdstip van de eerste checkin wordt bijgehouden. Deze informatie kan gebruikt worden om statistieken van locaties te genereren. Een locatie of venue heeft een 'verified' attribuut indien een gebruiker zich via de webinterface (zie sectie \ref{Webinterface} voor meer informatie over het doel en de werking van de webinterface) verifieerd. Een geverifieerde gebruiker (meestal een locatie eigenaar) in combinatie met een geverifieerde locatie kan een promotie opstellen waaraan elke groep, indien zij voldoen aan de opgelegde participatievoorwaarden, kan deelnemen.

Zoals reeds aangehaald in voorgaande paragraaf bestaan er promoties. Promoties kunnen enkel aangemaakt worden door geverifieerde gebruikers op geverifieerde plaatsen. Naast promoties bestaan er ook gewone events. Deze events kunnen aangemaakt worden door elke gebruiker. Aangezien deze gewone events niet zichtbaar zijn voor elke groep op Triump moet de organisator groepen, waartoe hij of zij zelf behoort, uitnodigen. 
Deze twee types events worden beiden bijgehouden in Event entiteiten. De verified bit geeft aan of een het event entiteit een promotie of een gewoon event is. De attributen minParticipants en maxParticipants hebben enkel een geldige waarde voor promoties. Een promotie organisator kan namelijk beslissen een verschillende promotie te lanceren afhankelijk van de groepgrootte (vb: groepen met een ledenaantal tussen de 100 en 150 strijden voor een gratis pint terwijl kleinere groepen van 5 tot 10 leden strijden voor een gratis etentje). De tabel GroupEvent wordt gebruikt om bij te houden welke groepen er zijn uitgenodigd op een gewoon event. Promoties komen niet voor in deze tabel aangezien impliciet wordt aangenomen dat elke groep eraan kan participeren.

Een checkin entiteit wordt aangemaakt iedere keer een gebruiker incheckt op een locatie. Het 'points' attribuut geeft aan hoeveel punten een checkin waard is. In de huidige implementatie geldt er dat elke checkin 1 punt waard is. Het is echter mogelijk de app uit te breiden en te voorzien dat bepaalde combinaties van inchecken meer punten opleveren. De attributen tijdstip en groep worden bijgehouden om te berekenen welke groep een bepaalde promotie heeft gewonnen. (Meer informatie over deze berekeningen volgt in sectie backend API.)

Elke gebruiker van Triump is in staat zijn eigen groepen aan te maken. De maker van een groep is ook de administrator ervan. Opnieuw kan het 'type' attribuut gebruikt worden om statistieken te generen van de beste studentvereniging of meest actieve vriendengroep. 'numMembers' is afgeleide data aangezien de waarde kan berekend worden uit het aantal entiteiten in de UserGroup tabel. Toch wordt 'numMembers' bijgehouden in group entiteiten aangezien dit een waarde is die vaak gebruikt wordt. Voordelen hiervan zijn een verbetering van de performantie en een vermindering van het aantal leesoperaties het nadeel hiervan is de mogelijkheid tot het optreden van anomalieën (vb: indien 'numMembers' niet overeenstemt met het aantal entiteiten in UserGroup voor een bepaalde groep).

UserGroup entiteiten koppelen een gebruiker met een groep. Een entiteit wordt aangemaakt wanneer een gebruiker een aanvraag doet om tot een groep te behoren. Het 'accepted' attribuut wordt bij de aanmaak op 0 geplaatst tot de administrator toestemming geeft aan de gebruiker om lid te worden van de groep. Indien de administator het lidschapverzoek weigert, wordt de entiteit verwijderd.

Tot slot wordt in UserEvent entiteiten bijgehouden welke gebruikers een promotie of event gewonnen hebben en bijgevolg een prijs verdienen. Het 'received' attribuut geeft aan indien een gebruiker zijn prijs reeds heeft gebruikt.

\begin{figure}[H]
	\includegraphics[scale=0.43]{backend_EER}
	\caption{Entity Relation diagram van de kern van de backend database}
	\label{fig:Backend ER}
\end{figure}

Figuur \ref{fig:Backend ER 2} toont het overige deel van de backend database. Wanneer een gebruiker zich voor het eerst authenticeert met de backend wordt er een SessionToken gekoppeld met de gebruiker. Deze token wordt meegegeven als parameter met iedere API call om de een gebruiker te authenticeren. 

De laatste tabel van de backend database houdt voor iedere gebruiker een gcmId bij. Deze ID wordt gebruikt voor de Google Cloud Messaging dienst.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.45]{backend_EER_deel2}
	\caption{Entity Relation diagram van het administratieve deel van de backend database}
	\label{fig:Backend ER 2}
\end{figure}

\subsubsection{backend API}
\label{backend API}
% generateRewards
De backend API bestaat uit een reeks methodes die kunnen opgeroepen worden vanop het mobiele toestel of vanop de webinterface. Dit is weergegeven met pijlen (3) en (5) op figuur \ref{fig:algemene structuur backend}. 

Een groot deel van de methodes hebben als doel het ophalen van gegevens uit de database, deze gegevens te mappen op een javaBean om vervolgens de bean terug te geven als resultaat. De voornaamste methodes van dit soort API calls zijn opgelijst in codefragment \ref{backend API}.


\begin{lstlisting}[caption={backend API methode signaturen ter opvraging van database informatie},label=lst:backend_api]
GroupsBean getAllGroups(String UserToken);
GroupsBean getGroupsForUser(String UserToken);
GroupBean getGroupInfo(String UserToken, long GroupId);
UsersBean getPendingRequest(String UserToken, long GroupId); 
	// geeft de lidmaatschapaanvragen van een groep terug

EventsBean getEventsForUser(String UserToken);
EventsBean getEventsForVenue(String UserToken, String VenueId);
RankingBean getRankingForEvent(String UserToken, long EventId);

VenueBean getVenueInfo(String UserToken, String VenueId);

UserBean getUserInfo(String UserToken);
OverviewBean getOverviewForUser(String UserToken);
\end{lstlisting}

Een tweede soort API calls wordt gebruikt om entiteiten van de tabellen Group, Event, UserGroup en UserEvent aan te maken of up te daten. De belangrijkste methode van dit soort is generateRewards(). De methode generateRewards() wordt vanuit een cronjob (zie sectie \ref{sec: GCE} Cron jobs) ieder kwartier opgeroepen. Prinicpieel werkt de functie als volgt:
\begin{enumerate}
  \item Controleert of er het afgelopen kwartier een event is beëindigd.
  \item Gaat voor elk beëndigd event bereken welke groepen gewonnen zijn a.d.h.v. de tijdstippen van de checkin entiteiten. Hierbij wordt er rekening gehouden met participatievoorwaarden zoals het minimaal en maximaal aantal leden van een groep.
  \item De leden van een winnende groep worden geplaast in de UserEvent tabel.
  \item Via het notificatiesysteem (zie sectie \ref{sec: GCE} Google Cloud Messaging) worden de winnende gebruikers verwittigd.
\end{enumerate}
Een beperking van dit systeem is dat een gebruiker gemiddeld 7,5 minuten moet wachten alvorens een notificatie van winst te ontvangen. Het is wel mogelijk de oproepfrequentie van de Cron job te verhogen.

Tot slot bevat de backend API nog methodes die gebruikers registeren, gebruikers authenticeren en communiceren met de GCM diensten. 

\subsection{Foursquare API}
\label{Foursquare API}

%Korte inleiding gebruik API
Zoals reeds eerder aangehaald maakt Triump gebruikt van locaties, deze locaties worden bekomen via de Foursquare API. De Foursquare API geeft de mogelijkheid aan ontwikkelaars om enorme gebruiker gegenereerde database van Foursquare te raadplegen. Naast locatie gegevens kan er ook informatie van gebruikers zoals namen geboortedata en profielfoto's opgevraagd worden.  Het mobiele toestel zal rechtstreeks requests sturen naar de foursquare API om bijvoorbeeld een lijst te krijgen van dichtbijzijnde locaties of om informatie van een locatie op te vragen. Het gebruik van de API wordt getoond in figuur \ref{fig:algemene structuur backend} pijl (1).

% Overzicht voor en nadelen gebruik API
Het werken met de API brengt echter wel nadelen met zich mee.
Allereerst wordt Triump hierdoor afhankelijk van een externe organisatie. Indien Foursquare beslist zijn open database te sluiten moet het ontwerp van Triump volledig herzien worden. Daarnaast wordt van commerciële applicaties verwacht dat ze reclame maken voor Foursquare door bijvoorbeeld het Foursquare logo op op te nemen in de layout.  Een tweede nadeel is dat de dataopslag verdeeld wordt over twee databases. Enerzijds de Google Cloud Datastore waar de data over groepen en checkins worden bijgehouden en anderzijds de Foursquare Datastore waar de locatie en gebruikergegevens zijn opgeslaan. Een laatste nadeel is dat locaties verplicht geregisteerd moeten zijn bij Foursquare teneinde zichtbaar te zijn op Triump. 

Indien locaties intern zouden aangemaakt en opgeslaan worden zouden de eerste twee nadelen verholpen zijn. 
Deze voor de hand liggende oplossing wordt echter niet toegepast aangezien dit zou impliceren dat Triump vanaf nul zijn locatiedatabase zou moeten vullen. Hierdoor zouden gebruikers ontmoedigd worden Triump boven Foursquare te kiezen. Daarnaast biedt Triump de optie een checkin door te propageren naar Foursquare waardoor we de functionaliteiten ervan uitbreiden. 

Het laatste probleem wordt opgelost door het voorzien van een webinterface. Deze interface voorziet de mogelijkheid aan eigenaars van locaties om de nodige informatie omtrent hun café, zaak of restaurant zichtbaar te maken op Triump. Meer uitleg over de website volgt hieronder.

Er dient opgemerkt te worden dat Google met 'Google Places' gelijkaardige diensten biedt. Gebruik van deze API heeft dezelfde voor- en nadelen als de Foursquare API maar met de bijkomende beperking dat het aantal geregistreerde locaties veel kleiner is.


%werking API
Het mechanisme gebruik in de Foursquare API is zeer vanzelfsprekend. Alle gegevens, opgeslaan in de database, corresponeren met een RESTful (Representational State Transfer) Uniform Resource Locator (URL)  \cite{FS_API_website}. De frontend applicatie dient een connectie over HTTPS te starten met een Foursquare API Endpoint via de gewenste URL. Vervolgens zal de API Endpoint de gevraagde informatie in Javascript Object Notation (JSON) formaat terugzenden. JSON is een gestandaardiseerd gegevensformaat. JSON maakt gebruik van voor de mens leesbare tekst in de vorm van data-objecten die bestaan uit een of meer attributen met bijbehorende waarde. Het wordt hoofdzakelijk gebruikt voor uitwisseling van data tussen server en webapplicatie, als een alternatief voor xml. Het voordeel van JSON is de platformonafhankelijkheid \cite{JSON_def}. In listing ~\ref{lst:vb_foursquare_api} wordt een voorbeeld uitgewerkt waarbij de applicatie vanop de smartphone de informatie van een bepaalde locatie opvraagd.


\begin{lstlisting}[caption={Voorbeeld: werking Foursquare API},label=lst:vb_foursquare_api]

HTTPS connectie naar URL:
https://api.foursquare.com/v2/venues/4d972f73af3d236ad0561cc7?
	oauth_token=OMUUXC42I4GCMV3G21&v=20150101&m=foursquare

Antwoord:
"venue":
	{
	"id":"4d972f73af3d236ad0561cc7",
	"name":"POM D' API BRUXELLES",
	"contact":{},
	"location":
		{
		"address":"Koninginnegallerij",
		"lat":50.0,"lng":4.0,
		"postalCode":"1000",
		"city":"Brussels",
		"state":"Bruxelles-Capitale",
		"country":"Belgium",
		"formattedAddress":
		["Koninginnegallerij","1000 Brussels"]
		}
	}
\end{lstlisting}
 


\section{Frontend}
\subsection{Android applicatie}
\subsubsection{Waarom Android}
% Keuze android boven iOS
% 
\subsubsection{Ontwikkelomgeving: Android Studio}
% vergelijking vs Eclipse
\subsubsection{Inloggen en authenticatie via Foursquare}

\subsubsection{Ontwerpkeuzes}
% Recycler view, nieuwste trends
% material design: welke lib. dat we gebruikt hebben
% Loadermechanismen
% Lokale SQLite DB
% Cardmechanisme

\subsection{Webinterface}
\subsubsection{Doel}
% De Waarom Vraag => !! zou dit niet beter eerder in het verslag al worden gezegd? !!
Voor een aantal taken is een smartphone niet helemaal geschikt. Deze heeft een klein scherm en de touchbediening is niet altijd handig. Zulke taken zijn het beheren van groepen en het aanmaken van promoties.
Deze taken moeten redelijk vaak gebeuren en gebeuren gemakkelijker op een groter scherm. Specifieke gebruikers, zoals uitbaters van locaties die een promotie willen opzetten om zo klanten te lokken, zullen deze taken willen uitvoeren. Daarom is Triump uitgebreid met een webinterface.
Onze site zal tevens dienst doen als infopunt voor huidige en toekomstige gebruikers. Op de site staat informatie over wat het doel is van Triump en waarom gebruikers
Op onze website kunnen gebruikers net als in de android-applicatie inloggen met Foursquare. Het is de bedoeling dat het registereren van een Foursquare-locatie steeds via de website gebeurd, net als het aanmaken van promoties door een eigenaar van een registreerde locatie.
\subsubsection{Django-framework}
Bij het maken van een website kan men verschillende keuzes maken.
Eerst en vooral is er de keuze of er gebruik wordt gemaakt van een bestaand framework, zoals Ruby on Rails, ASP.NET en Django, of dat men zelf de nodige functionaliteit implementeert met bijvoorbeeld PHP.
Omdat de webinterface slechts extra functionaliteit mogelijk maakt en dus niet het grootste deel van ons project is, werd besloten om deze voorlopig niet te uitgebreid te maken.
Het helemaal zelf opbouwen van de site is daarom een slecht idee: bestaande frameworks bieden ruim voldoende functionaliteit aan om onze website te maken. De frameworks zijn daarboven reeds geoptimaliseerd en bevatten functies zoals een standaardmanier om gebruikers veilig in te loggen. Het inloggen helemaal zelf implementeren daarintegen zou veel tijd en werk vragen, terwijl de kwaliteit naar alle waarschijnlijkheid beneden die van bestaande oplossingen zou liggen. 
Daarnaast moet men nog kiezen om ofwel de site bij een hosting-dienst te plaatsen, ofwel zelf de site te hosten op een eigen pc. De hosting zelf voorzien brengt vele moeilijkheden met zich mee: liefst wordt er gewerkt met een vast IP-adres, maar providers kennen aan gewone klanten slechts een tijdelijk IP-adres toe. Daarboven dient men dan ook de DNS-servers (minmaal 2) zelf te verzorgen.
De andere oplossing, gebruik maken van een hosting-dienst, is veel eenvoudiger. Voor een vast bedrag, per maand of jaar, wordt de website geplaatst op de servers van de hosting-dienst. Deze neemt extra moeilijkheden, zoals het instellen en onderhouden van DNS-servers op zich.
Het databasemanagment systeem (DBMS) moet ook nog worden gekozen indien dit van toepassing is. Hier was dit het geval: op de site worden gebruikers aangemaakt waarbij bepaalde informatie wordt opgeslaan, zoals hun Foursquare-identiteit, zodat de gebruiker maar 1 keer met Foursquare moet inloggen. \\
% figuur invoegen over structuur webinterface %
Als framework voor de webinterface werd gekozen voor Django. Dit framework maakt gebruik van de taal Python: een eenvoudig, maar krachtig taal. Django maakt het mogelijk om op relatief korte tijd toch een dynamische website te bouwen. Bij een dynamische website wordt de HTML-pagina die door de gebruiker wordt opgevraagd op het moment zelf door de server gegenereerd. Dit gebeurt door informatie uit bijvoorbeeld een databank op te halen, in ons geval de GCE backend, en dan een HTML-template in te vullen met deze informatie. Hierin ligt het verschil met statische websites, waar iedere gebruiker dezelfde vaste HTML-pagina's te zien krijgt.
Een voordeel van het werken met Django is dat er hosting-diensten bestaan die zich specialiseren in het hosten van Django-projecten. Wij kozen voor zo een dienst, namelijk http://djangoeurope.com.
Bij deze dienst was er de mogelijkheid te kiezen uit verschillende databasemanagment systemen. Er werd gekozen voor PostgreSQL: een open source DBMS waar wij reeds mee hebben gewerkt tijdens het vak "Databanken".

